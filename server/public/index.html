<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TalkBack Assistant - Ascolto Remoto</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* (CSS code remains the same as previous version) */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; align-items: center; justify-content: center; color: white; }
        .container { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); max-width: 500px; width: 90%; }
        h1 { font-weight: 300; margin-bottom: 20px; }
        .status-badge { display: inline-block; padding: 8px 15px; border-radius: 25px; margin-bottom: 30px; font-weight: 600; text-transform: uppercase; font-size: 0.9em; transition: all 0.3s ease; }
        .status-disconnected { background-color: #e74c3c; box-shadow: 0 0 15px rgba(231, 76, 60, 0.5); }
        .status-connected { background-color: #2ecc71; box-shadow: 0 0 15px rgba(46, 204, 113, 0.5); }
        .device-list { margin-bottom: 25px; text-align: left; padding: 10px 0; max-height: 150px; overflow-y: auto; border-top: 1px solid rgba(255, 255, 255, 0.2); border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
        .device-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; font-size: 0.9em; }
        .device-name { font-weight: 500; }
        .device-status { font-size: 0.8em; padding: 4px 8px; border-radius: 12px; }
        .device-status.active { background-color: #f1c40f; color: #333; }
        .device-status.inactive { background-color: #34495e; }
        .controls { display: flex; justify-content: space-around; margin-bottom: 30px; }
        .action-button { padding: 12px 25px; border: none; border-radius: 10px; font-size: 1em; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease; font-weight: 600; }
        #startButton { background-color: #3498db; color: white; }
        #startButton:hover { background-color: #2980b9; }
        #stopButton { background-color: #e74c3c; color: white; }
        #stopButton:hover { background-color: #c0392b; }
        .visualizer { display: flex; justify-content: center; align-items: flex-end; height: 50px; margin-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 10px; }
        .audio-bar { width: 8px; height: 4px; background-color: #f1c40f; margin: 0 2px; border-radius: 2px; transition: height 0.05s ease; }
    </style>
</head>
<body>
    <div class="container">
        <h1>TalkBack Assistant</h1>
        
        <div id="androidStatus" class="status-badge status-disconnected">
            Nessun dispositivo Android connesso
        </div>

        <div class="device-list" id="deviceList">
            <p style="font-size: 0.8em; opacity: 0.8;">Dispositivi rilevati:</p>
        </div>

        <div class="controls">
            <button id="startButton" class="action-button" disabled>AVVIA ASCOLTO</button>
            <button id="stopButton" class="action-button" disabled>FERMA ASCOLTO</button>
        </div>

        <div class="visualizer" id="audioVisualizer">
        </div>
    </div>
    
    <script>
        class TalkBackClient {
            constructor() {
                // ⚠️ CONFIGURATION: SET YOUR SERVER URL HERE ⚠️
                // ---------------------------------------------
                // If you are accessing the page via http://localhost:3000, set this to null.
                // If you are accessing it via a custom IP/Port (e.g., http://192.168.1.5:3000), 
                // and are experiencing connection issues, set it explicitly:
                const CUSTOM_SERVER_URL = null; // Example: "http://192.168.1.5:3000"

                const connectionUrl = CUSTOM_SERVER_URL || `${window.location.protocol}//${window.location.host}`;
                // ---------------------------------------------

                this.socket = io(connectionUrl, { 
                    path: "/ws/socket.io/",
                    forceNew: true,
                    // Ensure client is prepared for binary data
                    binary: true, 
                });
                this.audioContext = null;
                this.nextTime = 0; // The scheduled time for the next audio buffer to start
                this.audioBars = [];
                this.activeDeviceId = null; 
                this.isListening = false;
                this.SAMPLE_RATE = 44100; // Must match Android
                
                this.initElements();
                this.initListeners();
                this.initSocketEvents();
                this.initializeAudioContext();
                this.createVisualizerBars();
            }

            initElements() {
                this.statusElement = document.getElementById('androidStatus');
                this.deviceListElement = document.getElementById('deviceList');
                this.startButton = document.getElementById('startButton');
                this.stopButton = document.getElementById('stopButton');
                this.visualizerElement = document.getElementById('audioVisualizer');
            }

            initListeners() {
                this.startButton.addEventListener('click', () => this.startListening());
                this.stopButton.addEventListener('click', () => this.stopListening());
                
                // Resumes AudioContext on user interaction
                document.addEventListener('click', () => this.initializeAudioContext(), { once: true });
                document.addEventListener('touchend', () => this.initializeAudioContext(), { once: true });
            }

            initializeAudioContext() {
                if (!this.audioContext) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext({ sampleRate: this.SAMPLE_RATE });
                    this.nextTime = this.audioContext.currentTime;
                }
                
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }

            initSocketEvents() {
                this.socket.on('connect', () => {
                    console.log('Connesso al server Socket.IO');
                    // Immediately request the current list of devices from the server
                    this.socket.emit('web_client_connected', { browser: navigator.userAgent });
                    this.socket.emit('get_android_devices'); 
                });

                this.socket.on('disconnect', () => {
                    console.log('Disconnesso dal server');
                    this.updateStatus('DISCONNESSO', 'status-disconnected');
                    this.updateDeviceList([]);
                    this.setControlsEnabled(false, false);
                });

                this.socket.on('android_devices_updated', (devices) => {
                    this.updateDeviceList(devices);
                    if (devices.length > 0) {
                        // For simplicity, we assume the first connected device is the target
                        const firstDevice = devices[0];
                        this.activeDeviceId = firstDevice.id; 
                        this.isListening = firstDevice.isStreaming;
                        
                        this.updateStatus(
                            this.isListening ? 'STREAMING ATTIVO' : 'DISPOSITIVO ANDROID CONNESSO', 
                            this.isListening ? 'status-connected' : 'status-connected'
                        );
                        this.setControlsEnabled(!this.isListening, this.isListening); 
                    } else {
                        this.activeDeviceId = null;
                        this.isListening = false;
                        this.updateStatus('NESSUN DISPOSITIVO ANDROID CONNESSO', 'status-disconnected');
                        this.setControlsEnabled(false, false);
                    }
                });

                // ⚠️ CRITICAL: Receives a raw ArrayBuffer/Buffer (binary data)
                this.socket.on('audio_data', (packet) => { 
                    if (this.isListening) {
                        // The packet should be an ArrayBuffer from Socket.IO's binary handling
                        if (packet instanceof ArrayBuffer) {
                            this.handleAudioStream(packet);
                        } else {
                            console.error("Dato audio non in formato binario (ArrayBuffer) atteso.");
                        }
                    }
                });
                
                this.socket.on('listening_started', (response) => {
                    if (response.success) {
                        console.log(`Ascolto avviato su dispositivo: ${response.deviceId}`);
                        this.isListening = true;
                        this.updateStatus('STREAMING ATTIVO', 'status-connected');
                        this.setControlsEnabled(false, true);
                    } else {
                        console.error('Errore nell\'avvio dell\'ascolto:', response.error);
                        alert(`Errore: ${response.error}`);
                        this.setControlsEnabled(true, false);
                    }
                });

                this.socket.on('listening_stopped', (response) => {
                    if (response.success) {
                        console.log('Ascolto interrotto.');
                        this.isListening = false;
                        this.updateStatus('DISPOSITIVO ANDROID CONNESSO', 'status-connected');
                        this.setControlsEnabled(true, false);
                        this.nextTime = 0; // Reset playback queue time
                    } else {
                        console.error('Errore nell\'interruzione dell\'ascolto:', response.error);
                        alert(`Errore: ${response.error}`);
                        this.setControlsEnabled(false, true);
                    }
                });
            }

            updateStatus(message, className) {
                this.statusElement.textContent = message;
                this.statusElement.className = `status-badge ${className}`;
            }
            
            updateDeviceList(devices) {
                this.deviceListElement.innerHTML = devices.length > 0 
                    ? '<p style="font-size: 0.8em; opacity: 0.8;">Dispositivi rilevati:</p>' 
                    : '<p style="font-size: 0.8em; opacity: 0.8;">Nessun dispositivo rilevato</p>';
                
                devices.forEach(device => {
                    const item = document.createElement('div');
                    item.className = 'device-item';
                    item.innerHTML = `
                        <span class="device-name">${device.name}</span>
                        <span class="device-status ${device.isStreaming ? 'active' : 'inactive'}">
                            ${device.isStreaming ? 'Streaming' : 'Connesso'}
                        </span>
                    `;
                    this.deviceListElement.appendChild(item);
                });
            }

            setControlsEnabled(start, stop) {
                this.startButton.disabled = !start;
                this.stopButton.disabled = !stop;
            }

            startListening() {
                this.initializeAudioContext();
                if (this.activeDeviceId) {
                    this.socket.emit('start_listening', this.activeDeviceId);
                } else {
                    console.error("Nessun ID di dispositivo Android attivo. Impossibile avviare l'ascolto.");
                    alert("Si prega di connettere un dispositivo Android per avviare l'ascolto.");
                }
            }

            stopListening() {
                if (this.activeDeviceId) {
                    this.socket.emit('stop_listening', this.activeDeviceId);
                } else {
                    console.warn("Nessun dispositivo attivo da fermare.");
                }
            }
            
            // Helper to convert 16-bit PCM (signed short) to Web Audio API Float32
            int16ToFloat32(input) {
                const output = new Float32Array(input.length);
                for (let i = 0; i < input.length; i++) {
                    // Divide by 32768 (2^15) to normalize to the range [-1.0, 1.0]
                    output[i] = input[i] / 32768.0; 
                }
                return output;
            }

            // ⚠️ CRITICAL: Handle raw ArrayBuffer packet
            handleAudioStream(packet) { 
                if (!this.audioContext || this.audioContext.state !== 'running') {
                    return; 
                }

                try {
                    // 1. Convert raw 16-bit PCM data (ArrayBuffer) to Int16Array
                    // Assumes Little Endian, which is common for most desktop/mobile architectures
                    const int16Array = new Int16Array(packet);
                    
                    // 2. Convert Int16 to Web Audio API's Float32Array
                    const float32Array = this.int16ToFloat32(int16Array);
                    
                    const audioBufferNode = this.audioContext.createBuffer(
                        1, // Channels (Mono)
                        float32Array.length, 
                        this.SAMPLE_RATE
                    );
                    
                    const audioArray = audioBufferNode.getChannelData(0);
                    audioArray.set(float32Array, 0); 

                    const audioBufferSource = this.audioContext.createBufferSource();
                    audioBufferSource.buffer = audioBufferNode;
                    audioBufferSource.connect(this.audioContext.destination);
                    
                    let playTime = this.nextTime || this.audioContext.currentTime;
                    const currentTime = this.audioContext.currentTime;

                    // ⚠️ AGGRESSIVE BUFFER FLUSH: Jump ahead if lag exceeds 50ms
                    // This forces the stream to skip severely late packets instead of queuing them.
                    if (playTime < currentTime - 0.05) { 
                        console.log('Resetting audio schedule due to large lag. Buffer flushed.');
                        playTime = currentTime + 0.05; // Schedule next 50ms in the future
                    }
                    
                    audioBufferSource.start(playTime);

                    // Update the time for the *next* buffer to be scheduled
                    this.nextTime = playTime + audioBufferNode.duration;

                    this.updateAudioVisualizer(float32Array);
                    
                } catch (e) {
                    console.error('Errore nella riproduzione audio:', e);
                }
            }
            
            createVisualizerBars() {
                const numBars = 20;
                for (let i = 0; i < numBars; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    this.visualizerElement.appendChild(bar);
                    this.audioBars.push(bar);
                }
            }
            
            updateAudioVisualizer(float32Array) {
                // Calculate RMS or peak amplitude for visualization
                let sum = 0;
                for (let i = 0; i < float32Array.length; i++) {
                    sum += Math.abs(float32Array[i]);
                }
                const amplitude = sum / float32Array.length;
                
                this.audioBars.forEach((bar, index) => {
                    // Simple sine wave for variation, scaled by amplitude
                    const height = Math.max(4, amplitude * 50 * (1 + Math.sin(Date.now() * 0.01 + index) * 0.3));
                    bar.style.height = height + 'px';
                });
            }
        }
        
        // Inizializza l'app quando la pagina è caricata
        document.addEventListener('DOMContentLoaded', () => {
            new TalkBackClient();
        });
    </script>
</body>
</html>
